<?php
/**
 * Name: FOCUS Object Cache
 * Plugin URI: http://wordpress.org/plugins/focus-object-cache/
 * Description: File-based Object Cache is Utterly Slow: An Object Caching Dropin for WordPress that uses the local file system.
 * Version: 1.0.0
 * Text Domain: focus-cache
 * Author: Derrick Tennant
 * Author URI: https://emrikol.com/
 * GitHub Plugin URI: https://github.com/emrikol/focus/
 * License: GPLv3
 * License URI: http://www.gnu.org/licenses/gpl-3.0.html
 *
 * @package WordPress
 */

/**
 * Users with setups where multiple installs share a common wp-config.php or
 * $table_prefix can use this to guarantee uniqueness for the keys generated by
 * this object cache
 */
if ( ! defined( 'WP_CACHE_KEY_SALT' ) ) {
	define( 'WP_CACHE_KEY_SALT', '' );
}

/**
 * Defines the max expiry age for FOCUS objects.
 */
if ( ! defined( 'WP_FOCUS_MAXTTL' ) ) {
	define( 'WP_FOCUS_MAXTTL', YEAR_IN_SECONDS );
}

/**
 * From WordPress Core: Adds data to the cache, if the cache key doesn't already exist.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::add()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param int|string $key    The cache key to use for retrieval later.
 * @param mixed      $data   The data to add to the cache.
 * @param string     $group  Optional. The group to add the cache to. Enables the same key
 *                           to be used across groups. Default empty.
 * @param int        $expire Optional. When the cache data should expire, in seconds.
 *                           Default 0 (no expiration).
 * @return bool False if cache key and group already exist, true on success.
 */
function wp_cache_add( $key, $data, $group = 'default', $expire = 0 ) {
	global $wp_object_cache;
	return $wp_object_cache->add( $key, $data, $group, $expire );
}

/**
 * From WordPress Core: Adds a group or set of groups to the list of global groups.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::add_global_groups()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param string|array $groups A group or an array of groups to add.
 */
function wp_cache_add_global_groups( $groups ) {
	global $wp_object_cache;
	$wp_object_cache->add_global_groups( $groups );
}

/**
 * From WordPress Core: Closes the cache.
 *
 * This function has ceased to do anything since WordPress 2.5. The
 * functionality was removed along with the rest of the persistent cache.
 *
 * This does not mean that plugins can't implement this function when they need
 * to make sure that the cache is cleaned up after WordPress no longer needs it.
 *
 * @since 0.1.0
 *
 * @return true Always returns true.
 */
function wp_cache_close() {
	return true;
}

/**
 * From WordPress Core: Decrements numeric cache item's value.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::decr()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param int|string $key    The cache key to decrement.
 * @param int        $offset Optional. The amount by which to decrement the item's value. Default 1.
 * @param string     $group  Optional. The group the key is in. Default empty.
 * @return false|int False on failure, the item's new value on success.
 */
function wp_cache_decr( $key, $offset = 1, $group = 'default' ) {
	global $wp_object_cache;
	return $wp_object_cache->decr( $key, $offset, $group );
}

/**
 * From WordPress Core: Removes the cache contents matching key and group.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::delete()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param int|string $key   What the contents in the cache are called.
 * @param string     $group Optional. Where the cache contents are grouped. Default empty.
 * @return bool True on successful removal, false on failure.
 */
function wp_cache_delete( $key, $group = 'default' ) {
	global $wp_object_cache;
	return $wp_object_cache->delete( $key, $group );
}

/**
 * Removes cache contents for a given group.
 *
 * @since 0.1.0
 *
 * @uses $wp_object_cache Object Cache Class
 * @see WP_Object_Cache::delete_group()
 *
 * @param string $group Where the cache contents are grouped.
 * @return bool True on successful removal, false on failure
 */
function wp_cache_delete_group( $group ) {
	global $wp_object_cache;
	return $wp_object_cache->delete_group( $group );
}

/**
 * From WordPress Core: Removes all cache items.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::flush()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @return bool False on failure, true on success
 */
function wp_cache_flush() {
	global $wp_object_cache;
	return $wp_object_cache->flush();
}

/**
 * From WordPress Core: Retrieves the cache contents from the cache by key and group.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::get()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param int|string $key What the contents in the cache are called.
 * @param string     $group Where the cache contents are grouped.
 * @param bool       $force Whether to force an update of the local cache from the persistent cache (default is false).
 * @param bool       $found Whether key was found in the cache. Disambiguates a return of false, a storable value.
 * @return bool|mixed False on failure to retrieve contents or the cache contents on success
 */
function wp_cache_get( $key, $group = 'default', $force = false, &$found = null ) {
	global $wp_object_cache;
	return $wp_object_cache->get( $key, $group, $force, $found );
}

/**
 * From WordPress Core: Increment numeric cache item's value
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::incr()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param int|string $key    The key for the cache contents that should be incremented.
 * @param int        $offset Optional. The amount by which to increment the item's value. Default 1.
 * @param string     $group  Optional. The group the key is in. Default empty.
 * @return false|int False on failure, the item's new value on success.
 */
function wp_cache_incr( $key, $offset = 1, $group = 'default' ) {
	global $wp_object_cache;
	return $wp_object_cache->incr( $key, $offset, $group );
}

/**
 * From WordPress Core: Sets up Object Cache Global and assigns it.
 *
 * @since 0.1.0
 *
 * @global WP_Object_Cache $wp_object_cache
 */
function wp_cache_init() {
	global $wp_object_cache;
	$wp_object_cache = new WP_Object_Cache(); // override ok.
}

/**
 * From WordPress Core: Replaces the contents of the cache with new data.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::replace()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param int|string $key    The key for the cache data that should be replaced.
 * @param mixed      $data   The new data to store in the cache.
 * @param string     $group  Optional. The group for the cache data that should be replaced.
 *                           Default empty.
 * @param int        $expire Optional. When to expire the cache contents, in seconds.
 *                           Default 0 (no expiration).
 * @return bool False if original value does not exist, true if contents were replaced
 */
function wp_cache_replace( $key, $data, $group = 'default', $expire = 0 ) {
	global $wp_object_cache;
	return $wp_object_cache->replace( $key, $data, $group, $expire );
}

/**
 * From WordPress Core: Saves the data to the cache.
 *
 * Differs from wp_cache_add() and wp_cache_replace() in that it will always write data.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::set()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param int|string $key    The cache key to use for retrieval later.
 * @param mixed      $data   The contents to store in the cache.
 * @param string     $group  Optional. Where to group the cache contents. Enables the same key
 *                           to be used across groups. Default empty.
 * @param int        $expire Optional. When to expire the cache contents, in seconds.
 *                           Default 0 (no expiration).
 * @return bool False on failure, true on success
 */
function wp_cache_set( $key, $data, $group = 'default', $expire = 0 ) {
	global $wp_object_cache;
	return $wp_object_cache->set( $key, $data, $group, $expire );
}

/**
 * From WordPress Core: Switches the interal blog ID.
 *
 * This changes the blog id used to create keys in blog specific groups.
 *
 * @since 0.1.0
 *
 * @see WP_Object_Cache::switch_to_blog()
 * @global WP_Object_Cache $wp_object_cache Object cache global instance.
 *
 * @param int $blog_id Site ID.
 */
function wp_cache_switch_to_blog( $blog_id ) {
	global $wp_object_cache;
	return $wp_object_cache->switch_to_blog( $blog_id );
}

/**
 * From WordPress Core: Adds a group or set of groups to the list of non-persistent groups.
 *
 * @since 0.1.0
 *
 * @param string|array $groups A group or an array of groups to add.
 */
function wp_cache_add_non_persistent_groups( $groups ) {
	global $wp_object_cache;
	return $wp_object_cache->add_non_persistent_groups( $groups );
}

/**
 * From WordPress Core: Core class that implements an object cache.
 *
 * The WordPress Object Cache is used to save on trips to the database. The
 * Object Cache stores all of the cache data to memory and makes the cache
 * contents available by using a key, which is used to name and later retrieve
 * the cache contents.
 *
 * This implementation of the object cache uses flat files to store objects
 * and overrides the core non-persistent cache.
 *
 * @since 0.1.0
 */
class WP_Object_Cache {
	/**
	 * The amount of times the cache data was already stored in the cache.
	 *
	 * @since 0.1.0
	 * @access public
	 * @var int
	 */
	public $cache_hits = 0;

	/**
	 * Amount of times the cache did not have the request in cache.
	 *
	 * @since 0.1.0
	 * @access public
	 * @var int
	 */
	public $cache_misses = 0;

	/**
	 * Stores operations by group for stats
	 *
	 * @since 0.1.0
	 * @access private
	 * @var int
	 */
	var $group_ops = array();

	/**
	 * Holds the cached objects.
	 *
	 * @since 0.1.0
	 * @access private
	 * @var array
	 */
	var $cache = array();

	/**
	 * List of global cache groups.
	 *
	 * @since 0.1.0
	 * @access protected
	 * @var array
	 */
	var $global_groups = array();

	/**
	 * Groups that should not be stored in persistent cache.
	 *
	 * @since 0.1.0
	 * @access private
	 * @var array
	 */
	var $non_persistent_groups = array( 'comment' );

	/**
	 * The blog prefix to prepend to keys in non-global groups.
	 *
	 * @since 0.1.0
	 * @access private
	 * @var int
	 */
	var $blog_prefix;

	/**
	 * Directory where cache files are stored.
	 *
	 * @since 0.1.0
	 * @access private
	 * @var string
	 */
	var $cache_dir;

	/**
	 * Secret to use for a hash salt.
	 *
	 * @since 0.1.0
	 * @access private
	 * @var string
	 */
	var $secret = '';

	/**
	 * Default maximum cache expiry.
	 *
	 * @since 0.1.0
	 * @access private
	 * @var int
	 */
	public $default_expiration = WP_FOCUS_MAXTTL;

	/**
	 * Cache file header.
	 *
	 * @since 0.1.0
	 * @access private
	 * @var string
	 */
	var $cache_serial_header = '<?php /*';

	/**
	 * Cache file footer.
	 *
	 * @since 0.1.0
	 * @access private
	 * @var string
	 */
	var $cache_serial_footer = '*/ ?>';

	/**
	 * Sets up object properties.
	 *
	 * @since 0.1.0
	 *
	 * @global int $blog_id Global blog ID.
	 */
	function __construct() {
		global $blog_id;

		if ( defined( 'CACHE_PATH' ) ) {
			$this->cache_dir = CACHE_PATH;
		} else {
			$this->cache_dir = ABSPATH . 'wp-content' . DIRECTORY_SEPARATOR . 'focus-object-cache' . DIRECTORY_SEPARATOR;
		}

		$this->_mkdir( $this->cache_dir );

		$this->_salt_keys( WP_CACHE_KEY_SALT );
		$this->global_prefix = 'Global';
		$this->blog_prefix = 'WP';

		if ( function_exists( 'is_multisite' ) && is_multisite() ) {
			$this->blog_prefix = 'Site ' . $blog_id;
		}
	}

	/**
	 * Saves the object cache before object is completely destroyed.
	 *
	 * Called upon object destruction, which should be when PHP ends.
	 *
	 * @since 0.1.8
	 *
	 * @return true Always returns true.
	 */
	public function __destruct() {
		return true;
	}

	/**
	 * Adds data to the cache if it doesn't already exist.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @uses WP_Object_Cache::_isset_internal() Checks to see if the cache already has data.
	 * @uses WP_Object_Cache::set()             Sets the data after the checking the cache contents existence.
	 *
	 * @param int|string $key    What to call the contents in the cache.
	 * @param mixed      $data   The contents to store in the cache.
	 * @param string     $group  Optional. Where to group the cache contents. Default 'default'.
	 * @param int        $expire Optional. When to expire the cache contents. Default 0 (maximum expiration).
	 * @return bool False if cache key and group already exist, true on success
	 */
	public function add( $key, $data, $group = 'default', $expire = 0 ) {
		if ( wp_suspend_cache_addition() ) {
			return false;
		}

		$group = $this->_sanitize_cache_group( $group );
		$key = $this->_key( $key, $group );

		if ( $this->_isset_internal( $key, $group ) ) {
			return false;
		}

		$force = null;
		if ( false !== $this->get( $key, $group, false, $force, false ) ) {
			return false;
		}

		return $this->set( $key, $data, $group, (int) $expire );
	}

	/**
	 * Sets the list of global cache groups.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param array $groups List of groups that are global.
	 */
	public function add_global_groups( $groups ) {
		$groups = (array) $groups;

		// Add and dedupe groups.
		$groups = array_fill_keys( $groups, true );
		$this->global_groups = array_merge( $this->global_groups, $groups );
		$this->global_groups = array_unique( $this->global_groups );
	}

	/**
	 * Sets the list of non-persistent cache groups.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param array $groups List of groups that are global.
	 */
	public function add_non_persistent_groups( $groups ) {
		$groups = (array) $groups;

		// Add and dedupe groups.
		$groups = array_fill_keys( $groups, true );
		$this->non_persistent_groups = array_merge( $this->non_persistent_groups, $groups );
		$this->non_persistent_groups = array_unique( $this->non_persistent_groups );
	}

	/**
	 * Decrements numeric cache item's value.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param int|string $key    The cache key to decrement.
	 * @param int        $offset Optional. The amount by which to decrement the item's value. Default 1.
	 * @param string     $group  Optional. The group the key is in. Default 'default'.
	 * @return false|int False on failure, the item's new value on success.
	 */
	public function decr( $key, $offset = 1, $group = 'default' ) {
		$group = $this->_sanitize_cache_group( $group );
		$key = $this->_key( $key, $group );

		// Key/Group doesn't exist, return false.
		if ( ! $this->_isset_internal( $key, $group ) ) {
			return false;
		}

		// Sanitize value.
		$this->cache[ $group ][ $key ] = (int) $this->cache[ $group ][ $key ];

		// Sanitize offset.
		$offset = (int) $offset;

		// Decrement value.
		$this->cache[ $group ][ $key ] -= $offset;

		// Do not let value go negative.
		$this->cache[ $group ][ $key ] = max( 0, $this->cache[ $group ][ $key ] );

		// Save new value to the cache.
		$this->set( $key, $this->cache[ $group ][ $key ], $group, $this->_get_expiration( $key, $group ) );

		// Return new value.
		return $this->cache[ $group ][ $key ];
	}

	/**
	 * Removes the contents of the cache key in the group.
	 *
	 * If the cache key does not exist in the group, then nothing will happen.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param int|string $key        What the contents in the cache are called.
	 * @param string     $group      Optional. Where the cache contents are grouped. Default 'default'.
	 * @return bool False if the contents weren't deleted and true on success.
	 */
	public function delete( $key, $group = 'default' ) {
		$group = $this->_sanitize_cache_group( $group );
		$key = $this->_key( $key, $group );
		$return = true;

		// Key/Group doesn't exist, return false.
		if ( ! $this->_isset_internal( $key, $group ) ) {
			$return = false;
		}

		// Delete cached item and return true.
		unset( $this->cache[ $group ][ $key ] );

		// Delet the cache file.
		if ( $this->_focus_file_exists( $key, $group )  ) {
			unlink( $this->_get_focus_file( $key, $group ) ); // @codingStandardsIgnoreLine
		}

		// Stats.
		$this->group_ops[ $group ][] = 'Delete ' . $key;

		return $return;
	}

	/**
	 * Remove the contents of all cache keys in the group.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param string $group Optional. Where the cache contents are grouped. Default 'default'.
	 * @return bool False if not deleted and true on success.
	 */
	public function delete_group( $group = false ) {
		if ( false === $group ) {
			return false;
		}

		if ( ! $this->_should_persist( $group ) && ! isset( $this->cache[ $group ] ) ) {
			return false;
		}

		// Delete local cache group.
		unset( $this->cache[ $group ] );

		// Mark all files as expired, just in case delete times out.
		foreach ( glob( $this->cache_dir . $group . '/*.*' ) as $filename ) {
			if ( is_file( $filename ) ) {
				touch( $filename, time() - 3600 ); // @codingStandardsIgnoreLine
			}
		}

		// Delet the cache group dir.
		$this->_rm_cache_dir( $this->cache_dir . $group );

		return true;
	}

	/**
	 * Clears the object cache of all data.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @return true Always returns true.
	 */
	public function flush() {
		// Delete all data in cache directory, empty memory cache.
		$this->_rm_cache_dir( $this->cache_dir );
		$this->cache = array();
		return true;
	}

	/**
	 * Retrieves the cache contents, if it exists.
	 *
	 * The contents will be first attempted to be retrieved by searching by the
	 * key in the cache group. If the cache is hit (success) then the contents
	 * are returned.
	 *
	 * On failure, the number of cache misses will be incremented.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param int|string $key What the contents in the cache are called.
	 * @param string     $group Where the cache contents are grouped.
	 * @param string     $force Whether to force a refetch rather than relying on the local cache (default is false).
	 * @param bool       $found Optional. Whether the key was found in the cache. Disambiguates a return of false, a storable value. Passed by reference. Default null.
	 * @param bool       $stat  Optional. Whether or not to record stats.  Default true.
	 * @return bool|mixed False on failure to retrieve contents or the cache contents on success
	 */
	public function get( $key, $group = 'default', $force = false, &$found = null, $stat = true ) {
		$group = $this->_sanitize_cache_group( $group );
		$key = $this->_key( $key, $group );

		// Memory cache exists, please grab.
		if ( $this->_isset_internal( $key, $group ) && ! $force ) {
			// Stats.
			if ( $stat ) {
				$this->group_ops[ $group ][] = 'Hit (Mem): ' . $key;
				$this->cache_hits++;
			}

			$found = true;
			return $this->cache[ $group ][ $key ];
		}

		// FOCUS Cache file exists, please grab.
		if ( $this->_focus_file_exists( $key, $group ) ) {
			// If the object has expired, remove it from the cache and return false to force a refresh.
			if ( $this->_get_expiration( $key, $group ) < 0 ) {
				$this->delete( $key, $group );

				// Stats.
				if ( $stat ) {
					$this->group_ops[ $group ][] = 'Miss (Expired): ' . $key;
					$this->cache_misses++;
				}

				$found = false;
				return false;
			}

			$this->cache[ $group ][ $key ] = maybe_unserialize( base64_decode( substr( file_get_contents( $this->_get_focus_file( $key, $group ) ), strlen( $this->cache_serial_header ), - strlen( $this->cache_serial_footer ) ) ) ); // @codingStandardsIgnoreLine

			// Stats.
			if ( $stat ) {
				$this->group_ops[ $group ][] = 'Hit (FOCUS): ' . $key;
				$this->cache_hits++;
			}

			if ( is_object( $this->cache[ $group ][ $key ] ) ) {
				$found = true;
				return clone $this->cache[ $group ][ $key ];
			}

			$found = true;
			return $this->cache[ $group ][ $key ];
		}

		if ( $stat ) {
			$this->group_ops[ $group ][] = 'Miss (Empty): ' . $key;
			$this->cache_misses++;
		}
		$found = false;
		return false;
	}

	/**
	 * Increments numeric cache item's value.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param int|string $key    The cache key to increment.
	 * @param int        $offset Optional. The amount by which to increment the item's value. Default 1.
	 * @param string     $group  Optional. The group the key is in. Default 'default'.
	 * @return false|int False on failure, the item's new value on success.
	 */
	public function incr( $key, $offset = 1, $group = 'default' ) {
		$group = $this->_sanitize_cache_group( $group );
		$key = $this->_key( $key, $group );

		// Key/Group doesn't exist, return false.
		if ( ! $this->_isset_internal( $key, $group ) ) {
			return false;
		}

		// Sanitize value.
		$this->cache[ $group ][ $key ] = (int) $this->cache[ $group ][ $key ];

		// Sanitize offset.
		$offset = (int) $offset;

		// Increment value.
		$this->cache[ $group ][ $key ] += $offset;

		// Never go below 0.
		if ( $this->cache[ $group ][ $key ] < 0 ) {
			$this->cache[ $group ][ $key ] = 0;
		}

		// Save new value to the cache.
		$current_expiry = $this->_get_expiration( $key, $group );
		$this->set( $key, $this->cache[ $group ][ $key ], $group, $current_expiry );

		// Return new value.
		return $this->cache[ $group ][ $key ];
	}

	/**
	 * Replaces the contents in the cache, if contents already exist.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @see WP_Object_Cache::set()
	 *
	 * @param int|string $key    What to call the contents in the cache.
	 * @param mixed      $data   The contents to store in the cache.
	 * @param string     $group  Optional. Where to group the cache contents. Default 'default'.
	 * @param int        $expire Optional. When to expire the cache contents. Default 0 (no expiration).
	 * @return bool False if not exists, true if contents were replaced.
	 */
	public function replace( $key, $data, $group = 'default', $expire = 0 ) {
		$group = $this->_sanitize_cache_group( $group );
		$key = $this->_key( $key, $group );

		// Key/Group doesn't exist, return false.
		if ( ! $this->_isset_internal( $key, $group ) ) {
			return false;
		}

		return $this->set( $key, $data, $group, (int) $expire );
	}

	/**
	 * Sets the data contents into the cache.
	 *
	 * The cache contents is grouped by the $group parameter followed by the
	 * $key. This allows for duplicate ids in unique groups. Therefore, naming of
	 * the group should be used with care and should follow normal function
	 * naming guidelines outside of core WordPress usage.
	 *
	 * The $expire parameter is not used, because the cache will automatically
	 * expire for each time a page is accessed and PHP finishes. The method is
	 * more for cache plugins which use files.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param int|string $key    What to call the contents in the cache.
	 * @param mixed      $data   The contents to store in the cache.
	 * @param string     $group  Optional. Where to group the cache contents. Default 'default'.
	 * @param int        $expire Not Used.
	 * @return true Always returns true.
	 */
	public function set( $key, $data, $group = 'default', $expire = 0 ) {
		$group = $this->_sanitize_cache_group( $group );
		$key = $this->_key( $key, $group );

		if ( 0 === $expire ) {
			$expire = $this->default_expiration;
		}

		// Clone objects.
		if ( is_object( $data ) ) {
			$data = clone $data;
		}

		$this->cache[ $group ][ $key ] = $data;

		// Stats.
		$this->group_ops[ $group ][] = 'Set ' . $group . '/' . $key . ' (' . $expire . 's)';

		return $this->_save( $key, $data, $group, $expire );
	}

	/**
	 * Echoes the stats of the caching.
	 *
	 * Gives the cache hits, and cache misses. Also prints every cached group,
	 * key and the data.
	 *
	 * @since 0.1.0
	 * @access public
	 */
	public function stats() {
		?>
		<p><strong>Cache Hits:</strong> <?php echo esc_html( $this->cache_hits ); ?></p>
		<p><strong>Cache Misses:</strong> <?php echo esc_html( $this->cache_misses ); ?></p>
		<h3>Object Cache:</h3>
		<?php foreach ( $this->group_ops as $group => $ops ) : ?>
			<?php
			if ( ! isset( $_GET['debug_queries'] ) && 500 < count( $ops ) ) { // input var ok.
				$ops = array_slice( $ops, 0, 500 );
				echo "<big>Too many to show! <a href='" . esc_url( add_query_arg( 'debug_queries', 'true' ) ) . "'>Show them anyway</a>.</big>\n";
			}
			?>
			<h4><?php echo esc_html( $group ); ?> commands</h4>
			<div style="font-family: monospace;">
				<?php
				$lines = array();
				foreach ( $ops as $op ) {
					echo wp_kses_post( $this->_colorize_debug_line( $op ) . '<br/>' );
				}
				?>
			</div>
		<?php endforeach; ?>
		<?php
	}

	/**
	 * Switches the interal blog ID.
	 *
	 * This changes the blog ID used to create keys in blog specific groups.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param int $blog_id Blog ID.
	 */
	public function switch_to_blog( $blog_id = false ) { // @codingStandardsIgnoreLine
		if ( false === $blog_id || (int) $blog_id < 1 || ! is_multisite() ) {
			return false;
		}

		$this->blog_prefix = 'Site ' . (int) $blog_id;
	}

	/**
	 * Serves as a utility function to colorize cache stats.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param string $line Stats to be colorized.
	 * @return string HTML colorized stats.
	 */
	protected function _colorize_debug_line( $line ) {
		$colors = array(
			'Get' => 'green',
			'Set' => 'purple',
			'Add' => 'blue',
			'Delete' => 'red',
			'Hit' => 'orange',
			'Miss' => 'brown',
		);

		$cmd = substr( $line, 0, strpos( $line, ' ' ) );

		$cmd2 = '<span style="color:' . esc_attr( $colors[ $cmd ] ) . '">' . esc_html( $cmd ) . '</span>';

		return $cmd2 . substr( $line, strlen( $cmd ) );
	}

	/**
	 * Does this group use persistent storage?
	 *
	 * @since 0.1.0
	 *
	 * @param string $group Cache group.
	 * @return bool        true if the group is persistent, false if not.
	 */
	protected function _should_persist( $group ) {
		return empty( $this->non_persistent_groups[ $group ] );
	}

	/**
	 * Serves as a utility function to determine whether a key exists in the cache.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param int|string $key   Cache key to check for existence.
	 * @param string     $group Cache group for the key existence check.
	 * @return bool Whether the key exists in the cache for the given group.
	 */
	protected function _isset_internal( $key, $group ) {
		return isset( $this->cache[ $group ] ) && ( isset( $this->cache[ $group ][ $key ] ) || array_key_exists( $key, $this->cache[ $group ] ) );
	}

	/**
	 * Serves as a utility function to determine if a cache file exists.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param int|string $key   Cache key to check for existence.
	 * @param string     $group Cache group for the key existence check.
	 * @return bool Whether the cache file key exists.
	 */
	protected function _focus_file_exists( $key, $group ) {
		return file_exists( $this->_get_focus_file( $key, $group ) );
	}

	/**
	 * Serves as a utility function to determine the cache expiration.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param int|string $key   Cache key to check.
	 * @param string     $group Cache group for the key check.
	 * @return int Seconds until the cache expires.
	 */
	protected function _get_expiration( $key, $group ) {
		if ( $this->_focus_file_exists( $key, $group ) ) {
			return ( filemtime( $this->_get_focus_file( $key, $group ) ) - time() );
		}

		return 0;
	}

	/**
	 * Serves as a utility function to determine the cache file.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param int|string $key   Cache key to check.
	 * @param string     $group Cache group for the key check.
	 * @return string The cache file.
	 */
	protected function _get_focus_file( $key, $group ) {
		// Some characters might cause problems with the file system.
		$protected_chars = array(
			'/' => rawurlencode( '/' ),
			'\\' => rawurlencode( '\\' ),
			'?' => rawurlencode( '?' ),
			'*' => rawurlencode( '*' ),
			'|' => rawurlencode( '|' ),
			'"' => rawurlencode( '"' ),
			'\'' => rawurlencode( '\'' ),
			'<' => rawurlencode( '<' ),
			'>' => rawurlencode( '>' ),
			':' => rawurlencode( ':' ),
		);

		$key = str_replace( array_keys( $protected_chars ), $protected_chars, $key );

		return $this->cache_dir . $group . '/' . $key . '.php';
	}

	/**
	 * Normalizes key
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param int|string $key   Cache key to check.
	 * @param string     $group Cache group for the key check.
	 * @return string Normalized copy of key.
	 */
	public function _key( $key, $group ) {
		$group = $this->_sanitize_cache_group( $group );

		$prefix = $this->key_salt;

		if ( ! empty( $this->global_groups[ $group ] ) ) {
			$prefix .= $this->global_prefix;
		} else {
			$prefix .= $this->blog_prefix;
		}

		if ( empty( $prefix ) ) {
			$prefix = 'WP';
		}

		// Remove whitespace.
		$prefix = preg_replace( '/\s+/', '', $prefix );
		$key = preg_replace( '/\s+/', '', $key );

		$normalized_key = $prefix . ':' . $key;

		// Remove dulicate prefixes.  Where are these coming from?!
		$normalized_key = preg_replace( '/^' . $prefix . ':' . $prefix . ':/', $prefix . ':', $normalized_key );

		return $normalized_key;
	}

	/**
	 * Salts cache key prefix
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param string $key_salt Salt to use.
	 */
	protected function _salt_keys( $key_salt ) {
		if ( strlen( $key_salt ) ) {
			$this->key_salt = $key_salt . ':';
		} else {
			$this->key_salt = '';
		}
	}

	/**
	 * Serves as a utility function to create cache group directories.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param string $group Cache group for directory creation.
	 * @return string The cache group directory.
	 */
	protected function _make_group_dir( $group = 'default' ) {
		$cache_dir = $this->cache_dir;
		$make_dir = '';

		foreach ( explode( '/', $group ) as $subdir ) {
			$make_dir .= $subdir . '/';
			$this->_mkdir( $cache_dir . $make_dir );
		}

		return $cache_dir . $group . '/';
	}

	/**
	 * Serves as a utility function to create directories.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param string $dir Directory to create.
	 */
	protected function _mkdir( $dir ) {
		// Give the new dirs the same perms as wp-content.
		$stat = stat( ABSPATH . 'wp-content' );
		$dir_perms = $stat['mode'] & 0007777; // Get the permission bits.
		$file_perms = $dir_perms & 0000666; // Remove execute bits for files.

		// Make the base cache dir.
		if ( ! file_exists( $dir ) ) {
			if ( ! mkdir( $dir ) ) { // @codingStandardsIgnoreLine
				return false;
			}
			chmod( $dir, $dir_perms ); // @codingStandardsIgnoreLine
		}

		if ( ! file_exists( $dir . 'index.php' ) ) {
			touch( $dir . 'index.php' ); // @codingStandardsIgnoreLine
			chmod( $dir . 'index.php', $file_perms ); // @codingStandardsIgnoreLine
		}
	}

	/**
	 * Serves as a utility function to delete directories.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param string $dir Directory to delete.
	 */
	protected function _rm_cache_dir( $dir ) {
		$dir_object = @opendir( $dir ); // @codingStandardsIgnoreLine

		if ( false === $dir_object ) {
			return false;
		}

		while ( false !== ( $file_object = readdir( $dir_object ) ) ) {
			if ( '.' === $file_object || '..' === $file_object ) {
				continue;
			}

			$dir_path = $dir . DIRECTORY_SEPARATOR . $file_object;

			if ( is_dir( $dir_path ) ) {
				$this->_rm_cache_dir( $dir_path );
			} else {
				unlink( $dir_path ); // @codingStandardsIgnoreLine
			}
		}

		closedir( $dir_object );
		rmdir( $dir ); // @codingStandardsIgnoreLine
	}

	/**
	 * Serves as a utility function to create multisite cache group names.
	 *
	 * @since 0.1.0
	 * @access public
	 *
	 * @param int $group Cache group to sanitize.
	 * @return string Sanitized cache group.
	 */
	public function _sanitize_cache_group( $group ) {
		if ( empty( $group ) ) {
			$group = 'default';
		}
		return $group;
	}

	/**
	 * Serves as a utility function to save the cache data to a file.
	 *
	 * @since 0.1.0
	 * @access protected
	 *
	 * @param int|string $key    What to call the contents in the cache.
	 * @param mixed      $data   The contents to store in the cache.
	 * @param string     $group  Optional. Where to group the cache contents. Default 'default'.
	 * @param int        $expire Cache expiration.
	 */
	protected function _save( $key, $data, $group = 'default', $expire = 0 ) {
		$cache_dir = $this->cache_dir;

		if ( 0 === $expire ) {
			$expire = $this->default_expiration;
		}

		// Give the new dirs the same perms as wp-content.
		$stat = stat( ABSPATH . 'wp-content' );
		$dir_perms = $stat['mode'] & 0007777; // Get the permission bits.
		$file_perms = $dir_perms & 0000666; // Remove execute bits for files.

		// Make FOCUS Cache directories and temp file.
		$this->_mkdir( $cache_dir );
		$group_dir = $this->_make_group_dir( $group, $dir_perms );
		$cache_file = $this->_get_focus_file( $key, $group );
		$temp_file = tempnam( $cache_dir, 'tmp' ); // @codingStandardsIgnoreLine
		if ( false === $temp_file ) {
			return false;
		}

		// Serialize, Base64 Encode, and add Header/Footer.
		// `maybe_serialize()` causes issues with variable typing, can't use.
		$serial = $this->cache_serial_header . base64_encode( serialize( $data ) ) . $this->cache_serial_footer; // @codingStandardsIgnoreLine

		$fd = fopen( $temp_file, 'w' );
		if ( false === $fd ) {
			return false;
		}

		$fwrite = fwrite( $fd, $serial ); // @codingStandardsIgnoreLine
		if ( false === $fwrite ) {
			return false;
		}

		fclose( $fd );

		if ( ! rename( $temp_file, $cache_file ) ) { // @codingStandardsIgnoreLine
			unlink( $temp_file ); // @codingStandardsIgnoreLine
			return false;
		}

		$chmod = chmod( $cache_file, $file_perms ); // @codingStandardsIgnoreLine
		if ( false === $chmod ) {
			return false;
		}

		// Set expiry.
		$touch = touch( $cache_file, time() + $expire ); // @codingStandardsIgnoreLine
		if ( false === $touch ) {
			return false;
		}
		return true;
	}
}
